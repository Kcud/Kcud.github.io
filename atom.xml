<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kcud.github.io/</id>
    <title>花花的小窝</title>
    <updated>2023-04-11T03:46:58.906Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kcud.github.io/"/>
    <link rel="self" href="https://kcud.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://kcud.github.io/images/avatar.png</logo>
    <icon>https://kcud.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, 花花的小窝</rights>
    <entry>
        <title type="html"><![CDATA[二分查找]]></title>
        <id>https://kcud.github.io/post/er-fen-cha-zhao/</id>
        <link href="https://kcud.github.io/post/er-fen-cha-zhao/">
        </link>
        <updated>2023-04-11T03:44:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="二分查找">二分查找</h2>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">复</mi><mi mathvariant="normal">杂</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">：</mi><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo><mi mathvariant="normal">幂</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">二</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">坏</mi><mi mathvariant="normal">情</mi><mi mathvariant="normal">况</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">数</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">待</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">找</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">为</mi><mn>8</mn><mo separator="true">,</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>8</mn><mo>=</mo><mn>3</mn><mi mathvariant="normal">。</mi></mrow><annotation encoding="application/x-tex">时间复杂度：O(logN)幂对数时间。二分最坏情况下运行次数log_2N，如果待查找的列表（数组）长度为8,log_28 = 3。
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">杂</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mord cjk_fallback">幂</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">坏</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">待</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">找</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">为</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord cjk_fallback">。</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">那</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">何</mi><mi mathvariant="normal">计</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">呢</mi><mi mathvariant="normal">？</mi><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">那这是如何计算的呢？2^3 = 8
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">何</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">呢</span><span class="mord cjk_fallback">？</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span></span></p>
<pre><code class="language-python">def binary_search(number_list,search_number):
    lower = 0
    heigh = len(number_list)-1
    mid = -1
    while lower &lt;= heigh:
        mid = (lower + heigh) // 2
        if number_list[mid] == search_number:
            return mid
        elif number_list[mid] &gt; search_number:
            heigh = mid -1
        else:
            lower = mid +1
        count += 1
    return -1
index = binary_search([1,3,5,6,8,10,12,24],1)
print(index)

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://note.youdao.com/yws/api/personal/file/WEB2a846dadf3bc3540626817f7487ff1e2?method=download&amp;shareKey=592c4b65c757578b7f58a4221b59110e" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[QKL]]></title>
        <id>https://kcud.github.io/post/qkl/</id>
        <link href="https://kcud.github.io/post/qkl/">
        </link>
        <updated>2023-04-05T05:32:41.000Z</updated>
        <content type="html"><![CDATA[<p>QKL</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS 安装 Redis]]></title>
        <id>https://kcud.github.io/post/centos-an-zhuang-redis/</id>
        <link href="https://kcud.github.io/post/centos-an-zhuang-redis/">
        </link>
        <updated>2023-03-07T09:04:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="需要的软件">需要的软件</h3>
<ul>
<li>VMware</li>
<li>XFtp(https://www.xshell.com/zh/free-for-home-school/)</li>
</ul>
<h3 id="安装centos">安装CentOS</h3>
<pre><code>//更新Yum
yum update -y
//下载wget
yum install -y wget
//vim
yum install -y vim-enhanced
//net-tools
yum install -y net-tool.x86_64
//gcc
yum install -y gcc tcl
</code></pre>
<h3 id="安装redis">安装redis</h3>
<p>下载Redis</p>
<p>https://redis.io/download/</p>
<p>通过xftp上传的centos 打开上传文件夹启动控制台</p>
<pre><code>tar -zxvf redis-7.0.9.tar.gz
</code></pre>
<p>进入解压目录</p>
<pre><code>make &amp;&amp; make install
</code></pre>
<p>打开redis.conf</p>
<pre><code>bind 0.0.0.0
daemonize yes
requirepass 123456
</code></pre>
<p>打开端口</p>
<pre><code>firewall-cmd --add-port=6379/tcp --permanent
</code></pre>
<p>启动服务</p>
<pre><code>redis-server redis.conf //需要在redis.conf所在的目录下使用
</code></pre>
<p>查看redis进程</p>
<pre><code>ps -ef | grep redis
</code></pre>
<p>停止redis</p>
<pre><code>kill -9 redis 进程号
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C 字符串 转 双精度]]></title>
        <id>https://kcud.github.io/post/c-zi-fu-chuan-zhuan-shuang-jing-du/</id>
        <link href="https://kcud.github.io/post/c-zi-fu-chuan-zhuan-shuang-jing-du/">
        </link>
        <updated>2022-06-06T15:49:41.000Z</updated>
        <content type="html"><![CDATA[<p>支持 正数、负数、浮点数的转化</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
/*
    统计字符数组长度
*/
int get_string_len(char *str)
{
    int len = 0;
    while(str[len])
    {
        len++;
    }
    return len;
}
/*
    将无符号部分转为 double
*/
double get_number(char *number_string)
{
    double result = 0;
    double decimal = 0;
    double digit = 0.1;
    int i = 0;
    int flag = 1;
    while(number_string[i])
    {
        if(!(number_string[i] &gt;='0' &amp;&amp; number_string[i] &lt;= '9') &amp;&amp; number_string[i] !='.')
            break;
        if(number_string[i] != '.' &amp;&amp; flag)
        {
            result = result * 10 + (number_string[i]-48);
        }
        else
        {
                flag = 0;
        }
        if(!flag &amp;&amp; number_string[i] !='.')
        {

            decimal = decimal + digit * (number_string[i]-48);
            digit = digit *0.1;
        }
        
        i++;
    }
    result=result+decimal;
    return result;
}

/*
    将字符数组转为double
    *number_string 字符指针
*/
double value(char *number_string)
{
    double result = 0;
    int len = 0;
    len = get_string_len(number_string);
    if(len &lt;= 0)
        return 0;
    else if((len == 1 &amp;&amp; number_string[0]&lt;'0' )|| (len == 1 &amp;&amp; number_string[0]&gt;'9'))
        return 0;
    else
    {
        if(number_string[0] == '-')
        {
            result = get_number(&amp;number_string[1])*-1;
        }
        else
        {
            result = get_number(number_string);
        }
    }
    return result;
}



int main()      // 演示代码
{
    char number[20];
    scanf(&quot;%s&quot;,number);
    while(1)
    {
        printf(&quot;%lf\n&quot;,value(number));
        scanf(&quot;%s&quot;,number);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c 读写 txt]]></title>
        <id>https://kcud.github.io/post/c-du-xie-txt/</id>
        <link href="https://kcud.github.io/post/c-du-xie-txt/">
        </link>
        <updated>2022-06-05T14:41:39.000Z</updated>
        <content type="html"><![CDATA[<p>仅支持西文字符</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
/*
    将字符串写入文本文件
    file_path 文件路径
    text 写入内容
    本方法使用追加写 如果文件不存在则创建
    正常结束返回 0
    出现异常返回 -1
*/
int write_txt_file(char *file_path, char *text)
{
    FILE *txt_file;
    txt_file = fopen(file_path,&quot;a&quot;);
    if(txt_file == NULL)
    {
        return -1;
    }
    fputs(text,txt_file);
    fclose(txt_file);
    return 0;
}
/*
    功能获取目标txt文件内容长度
    file_path 文件路径
    返回 文件内容长度
    文件不存在返回 -1
*/



int get_txt_file_context_len(char *file_path)
{
    FILE *txt_file;
    int len = 0;
    txt_file = fopen(file_path,&quot;r&quot;);
    if(txt_file == NULL)
    {
        return -1;
    }
    while(!feof(txt_file))
    {
        getc(txt_file);
        len++;
    }
    fclose(txt_file);
    return len;
}

/*
    读取文本文件中的字符
    file_path 文件路径
    请确保路径是正确的
    正常结束返回 字符指针
*/
char* read_txt_file(char *file_path)
{
    char* text;
    FILE *txt_file;
    int i = 0, len = 0;
    txt_file = fopen(file_path,&quot;r&quot;);
    if(txt_file == NULL)
    {
        text = (char*)malloc(sizeof(char));
        text = '\0';
        return text;
    }
    len = get_txt_file_context_len(file_path);
    text = (char*)malloc(sizeof(char) * (len+1));
    fgets(text,len,txt_file);
    fclose(txt_file);
    return text;
}


// 演示
int main()
{
    char *text;
    write_txt_file(&quot;D:/test.txt&quot;,&quot;test tex&quot;);
    text = read_txt_file(&quot;D:/test.txt&quot;);
    printf(&quot;%s&quot;,text);
    free(text);     //text是我们申请的内存 使用完释放
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序]]></title>
        <id>https://kcud.github.io/post/pai-xu/</id>
        <link href="https://kcud.github.io/post/pai-xu/">
        </link>
        <updated>2022-06-03T14:42:50.000Z</updated>
        <content type="html"><![CDATA[<p>快速排序</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


void quick_sort(int *array, int l, int r)
{
    int left =l;                //获取左下标 右下标
    int right = r;
    int pivot = array[left];    //对比用的标记
    if(left &gt;= right)           // 如果 左下标 &gt;= 右下标 则此区域排序结束
        return;
    while(left &lt; right)         //如果 左下标 小于 右下标
    {
        while(left &lt; right &amp;&amp; array[right] &gt;= pivot)    //在(left,right]区间 找到一个 小于 标记的数
        {
            right--;
        }
        if(left &lt; right)                                //判断是否 left right 是否合法
        {
            array[left] = array[right];                 //将小于 标记的数 放到数组的左边
        }
        while(left &lt; right &amp;&amp; array[left] &lt;= pivot)     //在(left,right]区间 找到一个 大于 标记的数
        {
            left++;
        }
        if(left &lt; right)                                //判断是否 left right 是否合法
        {
            array[right] = array[left];                 //将大于 标记的数 放到数组的右边
        }
        if(left == right)                               //当 left 与 right 重合
        {
            array[left] = pivot;                        // 将 标记数 移动到 重合的位置
        }
    }
    quick_sort(array,l,right-1);                        //递归 排序左右子区间
    quick_sort(array,right+1,r);

}

int main()
{
    int a[10],i;
    for(i = 0; i &lt; 10; i++)
        scanf(&quot;%d&quot;,&amp;a[i]);
    quick_sort(a,0,9);
    for(i = 0; i &lt; 10; i++)
        printf(&quot;%d &quot;,a[i]);
    return 0;
}

</code></pre>
<p>插入排序</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void insert_sort(int *array, int array_len)
{
    int i, j, key_number;
    for(i = 1; i &lt; array_len; i++)          //外循环 元素为1时默认有序 所以下标从 1 开始
    {
        key_number = array[i];              //将 i 上的值作为待排序值
        j = i - 1;                          //我们要将 待排序值 插入到 [0,i-1] 的位置上
        while(j &gt;= 0 &amp;&amp; array[j] &gt; key_number)  //找到比待插入值小的值
        {
            array[j+1] = array[j];
            j--;
        }
        array[j+1] = key_number;  //将待插入值 插入 因为 while 循环每次会 j-- 所以我们离正确的插入位置少了1
    }
}


int main()
{

    int a[10] = {1,4,7,2,5,8,3,6,9}, i;
    insert_sort(a,9);
    for(i = 0; i &lt; 9; i++)
        printf(&quot;%d &quot;,a[i]);
}

</code></pre>
<p>归并排序</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void merge(int * array, int * temp_array, int left, int mid, int right) //合并
{
    int left_flag, right_flag, temp_index;
    left_flag = left;       //左半区第一个元素
    right_flag = mid + 1;   //右半区第一个元素
    temp_index = left;		//临时数组的下标
    while(left_flag &lt;= mid &amp;&amp; right_flag &lt;= right)	//将左半区和右半区的数组合并到 temp_array
    {
        if(array[left_flag] &lt; array[right_flag])
        {
            temp_array[temp_index] = array[left_flag];
            left_flag++;
        }
        else
        {
            temp_array[temp_index] = array[right_flag];
            right_flag++;
        }
        temp_index++;
    }
    while(left_flag &lt;= mid)						//如果左半区还有剩余元素依次合并到 temp_array
    {
        temp_array[temp_index] = array[left_flag];
        left_flag++;
        temp_index++;
    }
    while(right_flag &lt;= right)					//如果右半区还有剩余元素依次合并到 temp_array
    {
        temp_array[temp_index] = array[right_flag];
        right_flag++;
        temp_index++;
    }
    while(left &lt;= right)						//将合并好的 temp_array 赋值给 array
    {
        array[left] = temp_array[left];
        left++;
    }
}

void split(int * array, int * temp_array, int left, int right)     //分治
{
    int mid;
    if(left &lt; right)            //如果元数组长度大于 1
    {
        mid = ( left + right ) / 2;
        split(array, temp_array, left, mid);
        split(array, temp_array, mid+1, right);
        merge(array, temp_array,left,mid,right);
    }


}

void merge_sort(int *array, int len)
{
    int * temp_array = (int*)malloc(len * sizeof(int));
    split(array, temp_array, 0, len-1);
    free(temp_array);
}

int main()
{
    int a[10] = {1,4,7,2,5,8,3,6,9}, i;
    merge_sort(a,9);
    for(i = 0; i &lt; 9; i++)
        printf(&quot;%d &quot;,a[i]);
    return 0;
}

</code></pre>
<p>希尔排序</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void shell_sort(int *array, int len)
{
    int i, j, interval, key_number;
    interval = len / 2;
    while(interval &gt; 0)     //间隔 &gt; 0
    {
        for(i = interval; i &lt; len; i++) //插入排序
        {
            key_number = array[i];
            j = i-interval;
            while(j &gt;= interval &amp;&amp; array[j] &gt; key_number)
            {
                array[j+interval] = array[j];
                j = j - interval;
            }
            array[j+interval] = key_number;
        }
        interval = interval / 2;    //设置间隔 
    }
}

int main()
{
    int a[10] = {1,4,7,2,5,8,3,6,9}, i;
    shell_sort(a,9);
    for(i = 0; i &lt; 9; i++)
        printf(&quot;%d &quot;,a[i]);

    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ REST 风格]]></title>
        <id>https://kcud.github.io/post/rest-feng-ge/</id>
        <link href="https://kcud.github.io/post/rest-feng-ge/">
        </link>
        <updated>2022-05-27T15:17:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="rest-风格">REST 风格</h1>
<h2 id="请求工具">请求工具</h2>
<p><a href="https://www.postman.com/">postman</a></p>
<p>传统描述</p>
<pre><code class="language-http">http://localhost/user/getById?id=1
http://localhost/user/saveUser
</code></pre>
<p>REST 描述</p>
<pre><code class="language-http">http://localhost/user/1		
http://localhost/user
</code></pre>
<p>隐藏 行为</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>查询</td>
</tr>
<tr>
<td>POST</td>
<td>( 新增/保存 )</td>
</tr>
<tr>
<td>PUT</td>
<td>修改</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">@RequestMapping(value=&quot;/users&quot;, method = RequestMethod.POST)

@RequestMapping(value=&quot;/users/{id}&quot;, method = RequestMethod.DELETE)
@ResponseBody
public String delete(@PathVariable Integer id){		//增加 PathVariable 注解
  //....
  return &quot;{'xxxx':'xxx'}&quot;;
}
</code></pre>
<table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ResponseBody</td>
<td>用于接收json数据</td>
<td>数据多</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>用于接收url地址参数或表单</td>
<td>使用的少</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>用于接收地址参数 {参数名称}</td>
<td>数据少</td>
</tr>
</tbody>
</table>
<h2 id="简化">简化</h2>
<p>去除重复的value</p>
<pre><code class="language-java">//在类名使用
@RequestMapping(&quot;xxxs&quot;)
@@ResponseBody
@RestController	//使用这个注解 @Controller 和 @ResponeBody 可以不再写 

//修改 删除
@RequestMapping(value=&quot;/{id}&quot;, method = RequestMethod.DELETE)
//可以简写为
@DeleteMapping(&quot;/{id}&quot;)

@RequestMapping( method = RequestMethod.POST)
//修改为
@PostMapping
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cpolar 实现内网穿透]]></title>
        <id>https://kcud.github.io/post/cpolar-shi-xian-nei-wang-chuan-tou/</id>
        <link href="https://kcud.github.io/post/cpolar-shi-xian-nei-wang-chuan-tou/">
        </link>
        <updated>2022-05-08T07:50:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用-cpolar-实现内网穿透">使用 Cpolar 实现内网穿透</h2>
<p><a href="https://www.cpolar.com/download">下载地址</a></p>
<p>下载完成后</p>
<img src="https://note.youdao.com/yws/api/personal/file/8C0925D66F9E4254BC01769BEC56ED19?method=download&shareKey=f70228df8a9ecec32258bd3da19f6f1c"/>
<img src="https://note.youdao.com/yws/api/personal/file/4CE1B10730154B918D6AA07E250EF31B?method=download&shareKey=f70228df8a9ecec32258bd3da19f6f1c"/>
<img src="https://note.youdao.com/yws/api/personal/file/ECCC9BFB86E440EE8CD26559B4F947C2?method=download&shareKey=f70228df8a9ecec32258bd3da19f6f1c"/>
<img src="https://note.youdao.com/yws/api/personal/file/15BEC6C843FA41298462DAC642DAE2B2?method=download&shareKey=f70228df8a9ecec32258bd3da19f6f1c"/>
<img src="https://note.youdao.com/yws/api/personal/file/43838C7C4A74482ABADC80357016A7E9?method=download&shareKey=f70228df8a9ecec32258bd3da19f6f1c"/>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python pip 时由于目标计算机积极拒绝,无法连接]]></title>
        <id>https://kcud.github.io/post/python-pip-shi-you-yu-mu-biao-ji-suan-ji-ji-ji-ju-jue-wu-fa-lian-jie/</id>
        <link href="https://kcud.github.io/post/python-pip-shi-you-yu-mu-biao-ji-suan-ji-ji-ji-ju-jue-wu-fa-lian-jie/">
        </link>
        <updated>2022-05-04T08:14:08.000Z</updated>
        <content type="html"><![CDATA[<p>1、按Win+R快捷键，输入regedit，打开注册表编辑器</p>
<p>2、找到HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings</p>
<p>3、将以 Proxy 打头的键值对（如ProxyEnable，ProxyOverride，ProxyServer等）全部删除</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git]]></title>
        <id>https://kcud.github.io/post/git/</id>
        <link href="https://kcud.github.io/post/git/">
        </link>
        <updated>2022-04-26T13:40:24.000Z</updated>
        <content type="html"><![CDATA[<p>git push -u origin master</p>
]]></content>
    </entry>
</feed>